<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[glider-gun's Blog]]></title>
  <link href="http://glider-gun.github.io/atom.xml" rel="self"/>
  <link href="http://glider-gun.github.io/"/>
  <updated>2015-12-22T00:49:19+01:00</updated>
  <id>http://glider-gun.github.io/</id>
  <author>
    <name><![CDATA[glider-gun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debugging Lisp Part 3: クラスの再定義]]></title>
    <link href="http://glider-gun.github.io/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi/"/>
    <updated>2015-12-22T00:35:33+01:00</updated>
    <id>http://glider-gun.github.io/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi</id>
    <content type="html"><![CDATA[<p>このエントリーは、著者の許可をいただいて <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a> のCommon Lispのデバッグに関する連載を翻訳するものです。</p>

<hr />

<p>このエントリーは連載 Debbugging Lisp の第3回です。第1回は<a href="http://glider-gun.github.io/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu">こちら</a>、第2回は<a href="http://glider-gun.github.io/blog/2015/12/22/debugging-lisp-part-2-insupekuto">こちら</a>。</p>

<p>Common Lisp Object System (CLOS) は非常に強力です。多重継承、多重ディスパッチ、メソッドの振る舞いを拡張するさまざまな異なるやり方を提供します。その内部では、ほとんどの実装は Metaobject Protocol(MOP) を使っています。これは CLOS 自身を使って CLOS を定義するものです。 MOP では、クラスはいくつかのインスタンス変数を持ったオブジェクトとして実装されます。そのインスタンス変数としては、クラス名、スーパークラス、またそのクラスの持つインスタンス変数のリストなどがあります。前回のエントリーの point クラスを見てみましょう:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defclass point ()
</span><span class='line'>  ((x :accessor point-x :initarg :x :initform 0)
</span><span class='line'>   (y :accessor point-y :initarg :y :initform 0)))</span></code></pre></td></tr></table></div></figure>


<p>そして Slime インスペクタを使って point クラスオブジェクトを見てみましょう。クラスオブジェクトは関数 <strong>find-class</strong> で見つけることができます:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize1.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-optimize1.gif" width="600"></p>

<p>MOP の利点は、 CLOS の振る舞いを微調整したいときには普通のオブジェクト指向プログラミングによって行えるということです。優れた例として、任意の述語(predecated)を CLOS のディスパッチに使えるようにする<a href="https://common-lisp.net/project/closer/filtered.html">filterd-functions</a>ライブラリがあります。MOPについてはもういいでしょう<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。このエントリーでは CLOS の小さな一部分である、 <strong>update-instance-for-redefined-class</strong> についてお話しします。</p>

<p><strong>update-instance-for-redefined-class</strong> は、クラスが(実行時に)再定義される度に呼ばれるメソッドです。これをオーバーライドすることでクラス再定義の際の振る舞いをカスタマイズすることが出来ます。
たとえば何かのシミュレーション中で、先ほどのpointクラスを複素数を表すのに使っていたとしましょう。シミュレーションの一部として、pointオブジェクトを変数 <em>*location*</em> に保存しています。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-1.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-optimize-1.gif" width="600"></p>

<p>シミュレーションをプロファイリングしてみると、ボトルネックの一つが複素数同士のかけ算であることに気付きました。複素数のかけ算は極座標表示での方がずっと効率的ですから、あなたは point クラスの実装を直交座標から極座標に変えることにしました。これを(実行中に)行うためには、次のコードを走らせるだけです:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmethod update-instance-for-redefined-class :before
</span><span class='line'>     ((pos point) added deleted plist &key)
</span><span class='line'>  (let ((x (getf plist 'x))
</span><span class='line'>        (y (getf plist 'y)))
</span><span class='line'>    (setf (point-rho pos) (sqrt (+ (* x x) (* y y)))
</span><span class='line'>          (point-theta pos) (atan y x))))
</span><span class='line'> 
</span><span class='line'>(defclass point ()
</span><span class='line'>  ((rho :initform 0 :accessor point-rho)
</span><span class='line'>   (theta :initform 0 :accessor point-theta)))
</span><span class='line'> 
</span><span class='line'>(defmethod point-x ((pos point))
</span><span class='line'>  (with-slots (rho theta) pos (* rho (cos theta))))
</span><span class='line'> 
</span><span class='line'>(defmethod point-y ((pos point))
</span><span class='line'>  (with-slots (rho theta) pos (* rho (sin theta))))</span></code></pre></td></tr></table></div></figure>


<p>これは要するに、 <strong>update-instance-for-redefined-class</strong> を拡張して、極座標実装での値 <em>rho</em> と <em>theta</em> を直交座標実装の値から計算するものです。 <strong>update-instance-for-redefined-class</strong> を拡張した後、このコードはクラスを再定義して、その時存在する全てのインスタンスを新しいクラスのインスタンスに変換します<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。
そして最後に、二つのメソッド <strong>point-x</strong> と <strong>point-y</strong> を定義し、 point クラスの元のインターフェースを保ちます<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。コードを走らせてから <em>*location*</em> の中身をインスペクトすると、次のようなものが見えるはずです:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-21.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-optimize-21.gif" width="600"></p>

<p><em>*location*</em> は依然として同一のオブジェクトを指しているものの、今やそれは極座標実装になっています！ 正しく変換されたことを確かめるため、あなたはこのオブジェクトを与えて <strong>point-x</strong> 関数を呼び出し、 x 座標が同じままかどうか確かめることにしました:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop1.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-crop1.gif" width="600"></p>

<p>驚くべきことに、クラスの実装を完全に置き換えたにもかかわらず、全てのコードは動作し続けます。もしあなたが24時間365日動き続けていなければならないサービス内でクラスの実装を変更したくて、しかもそれがたまたま Common Lisp で書かれていたなら、 <strong>update-instance</strong> を使うことを思い出してください。</p>

<p>原文: <a href="http://malisper.me/2015/07/22/debugging-lisp-part-3-redefining-classes/">http://malisper.me/2015/07/22/debugging-lisp-part-3-redefining-classes/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>MOPについてもっと学びたい方は、"The Art of the Metaobject Protocol"を手に取ってみてください。オブジェクト指向プログラミングを作った人であるアラン・ケイは、1997年のOOPSLAでの講演でこの本を「この10年で最も良い本」だと言いました。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>実際には、どの時点でupdate-instance-for-redefined-classが呼ばれるかは仕様では策定されていません。 保証されているのは、最初にインスタンス変数がアクセスされるまでに呼ばれるということだけです。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>本当にインターフェースを保存するためには initialize-instance などいくつか他の関数も定義し直す必要はあります。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Lisp Part 2: インスペクト]]></title>
    <link href="http://glider-gun.github.io/blog/2015/12/22/debugging-lisp-part-2-insupekuto/"/>
    <updated>2015-12-22T00:17:50+01:00</updated>
    <id>http://glider-gun.github.io/blog/2015/12/22/debugging-lisp-part-2-insupekuto</id>
    <content type="html"><![CDATA[<p>このエントリーは、著者の許可をいただいて <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a> のCommon Lispのデバッグに関する連載を翻訳するものです。</p>

<hr />

<p>このエントリーは連載 Debugging Lispの第2回です。第1回は<a href="http://glider-gun.github.io/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu">こちら</a>。</p>

<p>このエントリーではCommon Lispのもう一つのデバッグツール、Slimeのインスペクタについて議論します。
Slimeインスペクタは、オブジェクトをreplから直接操作することを可能にします。
色々なことができ、例えばオブジェクトをクリックして内容をみることもできますし、オブジェクトをコピーアンドペーストして後の関数呼び出しで使うこともできます<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。
次のようなpointクラスがあるとしましょう:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defclass point ()
</span><span class='line'>  ((x :accessor point-x :initarg :x :initform 0)
</span><span class='line'>   (y :accessor point-y :initarg :y :initform 0)))</span></code></pre></td></tr></table></div></figure>


<p>このクラスのインスタンスを作るには次のようにします:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(make-instance 'point :x 10 :y 20)</span></code></pre></td></tr></table></div></figure>


<p>返されたオブジェクトを右クリックして"inspect"オプションを選ぶか、emacsのショートカット"C-v C-v TAB"を使うことでオブジェクトの中をのぞくことができます:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-5.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-optimize-5.gif" width="600"></p>

<p>全てのインスタンス変数の現在の値が表示されます。表示するだけでなく、変数の値を変更することも出来ます。これらがデバッガ内から、実行時に使えることが強力なのだということに注意してください。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-7.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-optimize-7.gif" width="600"></p>

<p>実際にオブジェクトの値が変更されたことを確認するには、このオブジェクトをコピーアンドペーストし、 <strong>point-x</strong> 関数に与えて呼び出すことができます。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-5.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-crop-5.gif" width="600"></p>

<p>インスペクタに関してもう一つとてもクールなのは、Slimeのトレースダイアログです。トレースダイアログは普通のトレースに似ていますが、トレースされている関数が渡されたり返すオブジェクトがインスペクトできるようになっています。例えば、あなたが次のような末尾再帰最適化された関数 <strong>sum</strong> を書いているとしましょう。これはリストの中の全ての数を足し合わせます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun sum (xs &optional (acc 0))
</span><span class='line'>  (if (null xs)
</span><span class='line'>      acc
</span><span class='line'>      (sum (cdr xs) (+ (car xs) acc))))
</span><span class='line'> 
</span><span class='line'>(sum '(1 2 3))
</span><span class='line'>=&gt; 6</span></code></pre></td></tr></table></div></figure>


<p>関数 <strong>sum</strong> をトレースするかどうかは、ショートカット &ldquo;C-c M-t&rdquo; の後、関数の名前 &ldquo;<strong>sum</strong>&rdquo; を打つことで切り替えることができます。関数をトレースした後、"C-c T"でインタラクティブなトレースダイアログのバッファに入れます。"G"を押すことで情報を更新して一番最後のトレースを得ることができます。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-4.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-crop-4.gif" width="600"></p>

<p>このトレースは普通のトレースと大体同じ見た目をしていますが、よい機能があります。上で述べたように、関数の全ての引数と返り値をインスペクトすることができるのです。見やすいようにトレースの枝の表示/非表示を切り替えることも出来ます。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-8.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-22/ezgif.com-optimize-8.gif" width="600"></p>

<p>Slimeのトレースダイアログは、コードが多数のオブジェクトをやりとりしていて、自分がその中身について確信が持てないときに非常に有用です。これを使うだけであなたに必要な情報の全てを追ってくれるのです。</p>

<p>SlimeのインスペクタはCommon Lispのデバッグツール群のもう一つの素晴らしい機能です。プログラムがクラッシュし、原因が分からないときに重宝します。他のデバッグツール群と組み合わされば最高です。</p>

<p>原文: <a href="http://malisper.me/2015/07/14/debugging-lisp-part-2-inspecting/">http://malisper.me/2015/07/14/debugging-lisp-part-2-inspecting/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>技術的にはこれはインスペクタの機能ではなく"Presentation"の機能です。インスペクタはオブジェクトの中を見る機能にあたります。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Lisp Part 1: 再コンパイル]]></title>
    <link href="http://glider-gun.github.io/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu/"/>
    <updated>2015-12-19T01:52:44+01:00</updated>
    <id>http://glider-gun.github.io/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu</id>
    <content type="html"><![CDATA[<p>このエントリーは、著者 Michael Malis 氏の許可をいただき、Common Lispのデバッグに関する連載 <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a>  を翻訳するものです。</p>

<p>もともとは<a href="http://qiita.com/advent-calendar/2015/lisp">Lisp Advent Calendar 2015</a>の第18日目とし、全部翻訳して載せようかと思っていたのですが、間に合わなかったため第1回をまず掲載します。クリスマスまでに残りを掲載する予定です。サイトを作りたてでコメント欄は後で設置するつもりですが、その前に何かありましたらredditのコメント欄などは多分見てますので遠慮なくお寄せください。</p>

<hr />

<p>このエントリーはCommon Lispのデバッギング、特にEmacs、Slime、SBCLを用いた場合に関する連載の第1回です。Common Lispを知らない人でも少なくとも追うことはでき、Common Lispのデバッガが提供するものがいかにパワフルかわかるはずです。このエントリー群はNathan Marzに書くよう頼まれたものです。彼はCommon Lispをデバッグする多くのツール群がクールだと考えたのです。</p>

<p>Common Lispのデバッグを始めるに当たって最初に、あなたのLispで最適化の指定をする必要があります。Common Lispでは、コードのコンパイルにあたって何の項目を重要視すべきかを設定することができます。項目としてはたとえば実行速度、メモリ量、コンパイル速度、そしてデバッグがあります。以下のコードを走らせなければ、このエントリーで以下示すコードのほとんどは動作しません。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CL-USER&gt; (declaim (optimize (debug 3)))
</span><span class='line'>NIL
</span><span class='line'>
</span><span class='line'>CL-USER&gt; (your-program)
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>デバッグを優先してコンパイルすることにしたので、実行時に色々なことができるようになりました。
以下ではベテランのCommon Lisp開発者(トムとしましょう)に登場してもらい、彼がどのようにデバッグを行い、バグを含んだ関数を修正するかを示して行きます。トムの手元に、フィボナッチ関数を計算する次のようなコードがあるとします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun fib (n)
</span><span class='line'>  (if (&lt;= 0 n 1)
</span><span class='line'>      (/ 1 0)
</span><span class='line'>      (+ (fib (- n 1))
</span><span class='line'>         (fib (- n 2)))))</span></code></pre></td></tr></table></div></figure>


<p>このコードには問題が一つあります。正しくないということです！base caseでnを返すはずが、ゼロ除算を行ってしまいます。トムが10番目のフィボナッチ数を計算しようとするとデバッガウィンドウが現れます。エラーが通知されたからです。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-crop.gif" width="600"></p>

<p>トムはデバッガに入ったことに気付いて、何がまずかったのか考えます。バグを見つけるため、トムは関数にブレークポイントを挿入することにしました<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。Common Lispでは、ブレークポイントは関数として実装されており、"break"という名前です<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。ブレークポイントを挿入するため、トムは <strong>fib</strong> の最初に <strong>break</strong> の呼び出しを追加しました(訳注: 関数定義のコードにカーソルを置いてC-c C-cを押すことでその関数を再コンパイルします)。ブレークポイントを追加したトムは、次に一つのフレームのところにカーソルを持って行ったのち、'r'キーを押しました。これでそのフレームから実行を再開(リスタート)できます。トムは <em>n</em> が 3 だったフレームをリスタートすることにしました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-optimize.gif" width="600"></p>

<p>フレームをリスタートすることで、トムは要するにそのフレームまで時間を巻き戻すことができます。リスタートをすると、デバッガはトムが挿入したブレークポイントにただちにぶつかります。トムはそこから&rsquo;s'キーを押してプログラムを1ステップずつ実行します。最終的に彼は base case の実装が正しくないためにエラーが出ていることに気付きました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-2.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-optimize-2.gif" width="600"></p>

<p>さて、エラーの原因がわかりました。ブレークポイントを挿入したときと同じようにして、トムがコードを修正します。base caseを <em>n</em> で置き換えて、先ほど挿入したブレークポイントを取り除きました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-3.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-optimize-3.gif" width="600"></p>

<p>再コンパイルすると、トムはまたあるフレームからリスタートしました。先ほどコードをステップ実行していたところだったので、デバッガはフレームの中をステップ実行し始めました。トムが"0"(ゼロ)キーを押して step-continue という名のリスタートを呼ぶと、デバッガは通常実行に戻りました。このときトムはまだバグに遭遇する前のフレームからリスタートしたので、コードはあたかも最初からバグがなかったかのように走ります！</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-3.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-crop-3.gif" width="600"></p>

<p>まとめましょう。コードがエラーを通知すると、トムはデバッガに入っていることに気付きます。トムはコードにブレークポイントを挿入し、バグをつきとめるまでコードの振る舞いを追うことができます。トムがコードを修正したため、彼がフレームをリスタートするとコードは初めからバグがなかったかのように振る舞いました！</p>

<p>実行時にコードを再コンパイルできるのは、Common Lispが備えるたくさんの驚くべき特徴のうちたったひとつにすぎません。次回は、デバッガ内からオブジェクトを調べたり変更するための、Slimeのインスペクタについてお話しします。</p>

<p>原文: <a href="http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/">http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>彼はすばらしいプログラマーかもしれませんが、エラーメッセージを読まないのです。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>breakはそれ自体がCommon Lispのリスタート(restart)という仕組みで実装されています。リスタートについては第4回で扱います。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
