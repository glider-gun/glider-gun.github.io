<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[glider-gun's Blog]]></title>
  <link href="http://glider-gun.github.io/atom.xml" rel="self"/>
  <link href="http://glider-gun.github.io/"/>
  <updated>2015-12-19T02:21:57+01:00</updated>
  <id>http://glider-gun.github.io/</id>
  <author>
    <name><![CDATA[glider-gun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Debugging Lisp Part 1: 再コンパイル]]></title>
    <link href="http://glider-gun.github.io/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu/"/>
    <updated>2015-12-19T01:52:44+01:00</updated>
    <id>http://glider-gun.github.io/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu</id>
    <content type="html"><![CDATA[<p>このエントリーは、著者 Michael Malis 氏の許可をいただき、Common Lispのデバッグに関する連載 <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a>  を翻訳するものです。</p>

<p>もともとは<a href="http://qiita.com/advent-calendar/2015/lisp">Lisp Advent Calendar 2015</a>の第18日目とし、全部翻訳して載せようかと思っていたのですが、間に合わなかったため第1回をまず掲載します。クリスマスまでに残りを掲載する予定です。翻訳がおかしいとかありましたら遠慮なくお寄せください。</p>

<hr />

<p>このエントリーはCommon Lispのデバッギング、特にEmacs、Slime、SBCLを用いた場合に関する連載の第1回です。Common Lispを知らない人でも少なくとも追うことはでき、Common Lispのデバッガが提供するものがいかにパワフルかわかるはずです。このエントリー群はNathan Marzに書くよう頼まれたものです。彼はCommon Lispをデバッグする多くのツール群がクールだと考えたのです。</p>

<p>Common Lispのデバッグを始めるに当たって最初に、あなたのLispで最適化の指定をする必要があります。Common Lispでは、コードのコンパイルにあたって何の項目を重要視すべきかを設定することができます。項目としてはたとえば実行速度、メモリ量、コンパイル速度、そしてデバッグがあります。以下のコードを走らせなければ、このエントリーで以下示すコードのほとんどは動作しません。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CL-USER&gt; (declaim (optimize (debug 3)))
</span><span class='line'>NIL
</span><span class='line'>
</span><span class='line'>CL-USER&gt; (your-program)
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>デバッグを優先してコンパイルすることにしたので、実行時に色々なことができるようになりました。
以下ではベテランのCommon Lisp開発者(トムとしましょう)に登場してもらい、彼がどのようにデバッグを行い、バグを含んだ関数を修正するかを示して行きます。トムの手元に、フィボナッチ関数を計算する次のようなコードがあるとします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun fib (n)
</span><span class='line'>  (if (&lt;= 0 n 1)
</span><span class='line'>      (/ 1 0)
</span><span class='line'>      (+ (fib (- n 1))
</span><span class='line'>         (fib (- n 2)))))</span></code></pre></td></tr></table></div></figure>


<p>このコードには問題が一つあります。正しくないということです！base caseでnを返すはずが、ゼロ除算を行ってしまいます。トムが10番目のフィボナッチ数を計算しようとするとデバッガウィンドウが現れます。エラーが通知されたからです。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-crop.gif" width="600"></p>

<p>トムはデバッガに入ったことに気付いて、何がまずかったのか考えます。バグを見つけるため、トムは関数にブレークポイントを挿入することにしました<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。Common Lispでは、ブレークポイントは関数として実装されており、"break"という名前です<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。ブレークポイントを挿入するため、トムは <strong>fib</strong> の最初に <strong>break</strong> の呼び出しを追加しました(訳注: 関数定義のコードにカーソルを置いてC-c C-cを押すことでその関数を再コンパイルします)。ブレークポイントを追加したトムは、次に一つのフレームのところにカーソルを持って行ったのち、'r'キーを押しました。これでそのフレームから実行を再開出来ます。トムは <em>n</em> が 3 だったフレームをリスタートすることにしました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-optimize.gif" width="600"></p>

<p>フレームをリスタートすることで、トムは要するにそのフレームまで時間を巻き戻すことができます。リスタートをすると、デバッガはトムが挿入したブレークポイントにただちにぶつかります。トムはそこから&rsquo;s'キーを押してプログラムを1ステップずつ実行します。最終的に彼は base case の実装が正しくないためにエラーが出ていることに気付きました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-2.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-optimize-2.gif" width="600"></p>

<p>さて、エラーの原因がわかりました。ブレークポイントを挿入したときと同じようにして、トムがコードを修正します。base caseを <em>n</em> で置き換えて、先ほど挿入したブレークポイントを取り除きました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-3.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-optimize-3.gif" width="600"></p>

<p>再コンパイルすると、トムはまたあるフレームからリスタートしました。先ほどコードをステップ実行していたところだったので、デバッガはフレームの中をステップ実行し始めました。トムが"0"(ゼロ)キーを押してstep-continueという名のリスタートを呼ぶと、デバッガは通常実行に戻りました。このときトムはまだバグに遭遇する前のフレームからリスタートしたので、コードはあたかも最初からバグがなかったかのように走ります！</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-3.gif -->


<p><img class="center" src="http://glider-gun.github.io/images/2015-12-19/ezgif.com-crop-3.gif" width="600"></p>

<p>まとめましょう。コードがエラーを通知すると、トムはデバッガに入っていることに気付きます。トムはコードにブレークポイントを挿入し、バグをつきとめるまでコードの振る舞いを追うことができます。トムがコードを修正したため、彼がフレームをリスタートするとコードは初めからバグがなかったかのように振る舞いました！</p>

<p>実行時にコードを再コンパイルできるのは、Common Lispが備えるたくさんの驚くべき特徴のうちたったひとつにすぎません。次回は、デバッガ内からオブジェクトを調べたり変更するための、Slimeのインスペクタについてお話しします。</p>

<p>原文: <a href="http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/">http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>彼はすばらしいプログラマーかもしれませんが、エラーメッセージを読まないのです。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>breakはそれ自体がCommon Lispのリスタート(restart)という仕組みで実装されています。リスタートについては第4回で扱います。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
