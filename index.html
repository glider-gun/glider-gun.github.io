
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>glider-gun's Blog</title>
  <meta name="author" content="glider-gun">

  
  <meta name="description" content="CUIプログラムを作ろうとする時よく使われるライブラリとしてncursesというのがあります。
それのCommon Lispバインディングとしてはcl-charmsというのがあります。 練習として less コマンドのようなものを作ってみました。roswellスクリプトです。 1
./less. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://glider-gun.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="glider-gun's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71590051-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">glider-gun's Blog</a></h1>
  
    <h2>何か書きます</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="glider-gun.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/25/roswell-lesser-less/">Roswellでlessもどきを作ってみる</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-25T19:35:23+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>7:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>CUIプログラムを作ろうとする時よく使われるライブラリとしてncursesというのがあります。
それのCommon Lispバインディングとしては<a href="https://github.com/HiTECNOLOGYs/cl-charms">cl-charms</a>というのがあります。</p>

<p>練習として less コマンドのようなものを作ってみました。<a href="https://github.com/snmsts/roswell">roswell</a>スクリプトです。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./less.ros hoge.txt</span></code></pre></td></tr></table></div></figure>


<p>のようにして起動します。</p>

<p>機能としてはhjklか矢印キーで移動してqで終了するだけです。
文字幅を取得するのに cffi で wcwidth 関数を呼んでいます。</p>

<div><script src='https://gist.github.com/f93cb4471052cf6a0993.js?file=less.ros'></script>
<noscript><pre><code>#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 &quot;$@&quot;
|#
(ql:quickload :cl-charms :silent t)

(defun read-file (fname)
  &quot;return lines in fname&quot;
  (with-open-file (s fname)
    (loop for l = (read-line s nil nil)
       while l collect l)))

(defun char-width (c w)
  (cond ((char-equal c #\tab)
     (* (ceiling (1+ w) charms/ll:*tabsize*) charms/ll:*tabsize*))
    (t (+ w
          (cffi:foreign-funcall &quot;wcwidth&quot; :int (char-code c) :int)))))

(defun string-width (str)
  (loop for c across str
     with width = 0
     do (setf width (char-width c width))
     finally (return width)))

(defun main (&amp;rest argv)
  (declare (ignorable argv))
  (let*
      ((fname (car argv))
       (lines (read-file fname))
       (minrow 0)
       (mincol 0)
       scr
       pad
       pad-width
       pad-height)

    ;; initialize screen and pad
    (setf scr (charms/ll:initscr)
      pad-height (length lines)
      pad-width (loop for l in lines
               maximize (string-width l))
      pad (charms/ll:newpad pad-height pad-width))

    (charms/ll:cbreak)          ; get key input immediately,
                    ; but 
    (charms/ll:noecho)          ; don&#39;t display key inputted from user
    (charms/ll:keypad pad 1)        ; accept special keys like arrow keys
    (charms/ll:curs-set 0)      ; don&#39;t show cursor

    ;; initialize pad contents
    (loop for l in lines
       for y from 0
       do (charms::check-status (charms/ll:mvwaddstr pad y 0 l)))

    ;; draw pad
    (charms/ll:wclear scr)
    (charms::check-status
     (charms/ll:prefresh pad minrow mincol
             0 0
             (1- charms/ll:*LINES*) (1- charms/ll:*COLS*)))

    ;; main loop
    (loop named loop for k = (charms/ll:wgetch pad)
       do (cond ((= k (char-code #\q))
         (return-from loop))
        ((= k (char-code #\j))
         (incf minrow))
        ((= k (char-code #\k))
         (decf minrow))
        ((= k (char-code #\h))
         (decf mincol))
        ((= k (char-code #\l))
         (incf mincol))
        ((= k charms/ll:key_down)
         (incf minrow))
        ((= k charms/ll:key_up)
         (decf minrow))
        ((= k charms/ll:key_left)
         (decf mincol))
        ((= k charms/ll:key_right)
         (incf mincol))
        (t
         ;; (format t &quot;[~A ~C ~:C]~%&quot; k (code-char k) (code-char k))
         ;; (finish-output)
         ))
       do (charms/ll:wclear scr)
       do (charms/ll:wrefresh scr)
       do (charms/ll:prefresh pad minrow mincol
                  0 0
                  (1- charms/ll:*LINES*) (1- charms/ll:*COLS*)))
    (charms/ll:endwin)))
</code></pre></noscript></div>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/25/debugging-lisp-translation/">Debugging Lisp を翻訳しました</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-25T03:26:42+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Common Lispのデバッグに関する Michael Malis 氏の連載 <a href="http://malisper.me/category/debugging-common-lisp/">Debugging Lisp</a> の翻訳がひとまず終わりましたので、まとめてリンクを張っておきます。<a href="http://qiita.com/advent-calendar/2015/lisp">Lisp Advent Calendar 2015</a>の第18日目として第1回の記事へのリンクを張ってましたが、こっちに張り替えます。</p>

<ul>
<li><a href="/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu/">Debugging Lisp Part 1: 再コンパイル</a></li>
<li><a href="/blog/2015/12/22/debugging-lisp-part-2-insupekuto/">Debugging Lisp Part 2: インスペクト</a></li>
<li><a href="/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi/">Debugging Lisp Part 3: クラスの再定義</a></li>
<li><a href="/blog/2015/12/25/debugging-lisp-part-4-restart/">Debugging Lisp Part 4: リスタート</a></li>
<li><a href="/blog/2015/12/25/debugging-lisp-part-5-miscellaneous/">Debugging Lisp Part 5: その他こまごま</a></li>
</ul>


<p>つたない翻訳ではありますが、Common Lisp のデバッグ方法についてはあまり日本語で情報がないので、こういうのもあるといいのではないかと思い自分の勉強を兼ねて訳してみた次第です。英語圏でもあんまりみたことない素晴らしい内容ですし<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。
翻訳元のサイト <a href="http://malisper.me/">http://malisper.me/</a> には主にマクロについて他にも面白い記事があるので読める方は読むといいと思います。</p>

<p>ちなみにもともとは Qiita のエントリーにするつもりだったんですが、どうも Qiita が gif アニメーション画像に対応していないようだったので急遽 github io を使ってページを作っています。テーマとかまだいじるかもしれません。とりあえず<a href="https://codeiq.jp/magazine/category/programminggirls/">はしれ！コード学園</a> のLispちゃん会には間にあわせたいという裏目標は達成出来たのでよかったです。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>あんまり色々追っているわけでもないですが<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/25/debugging-lisp-part-5-miscellaneous/">Debugging Lisp Part 5: その他こまごま</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-25T02:12:41+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:12 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリーは、著者の許可をいただいて <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a> のCommon Lispのデバッグに関する連載を翻訳するものです。</p>

<hr />

<p>このエントリーは、それだけで記事にするほど大きくはないような細かな機能についてです。これまで<a href="/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu">再コンパイル</a>、<a href="/blog/2015/12/22/debugging-lisp-part-2-insupekuto">インスペクト</a>、<a href="/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi/">クラスの再定義</a>、<a href="/blog/2015/12/25/debugging-lisp-part-4-restart/">リスタート</a>を扱いました。</p>

<p>あまり有名でない機能として、 SBCL の <strong>trace</strong> があります。SBCL のトレース機能はほとんどの Common Lisp 実装のそれに比べはるかに高機能です。SBCL の <strong>trace</strong> はいくつかのキーワード引数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>を(訳注: Common Lispの仕様で決まっている他にも)追加で対応しています。例えば <strong>trace</strong> はキーワード変数 <em>:break</em> をとります。 <em>:break</em> の値として渡された式はトレース中の関数が呼ばれるたびに評価されます。そしてその式の値が真であるときにデバッガが呼び出されます。例えば次のようなフィボナッチ関数があったとしましょう:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun fib (n)
</span><span class='line'>  (if (&lt;= 0 n 1)
</span><span class='line'>      n
</span><span class='line'>      (+ (fib (- n 1))
</span><span class='line'>         (fib (- n 2)))))</span></code></pre></td></tr></table></div></figure>


<p><strong>trace</strong> を使って、 <strong>fib</strong> が引数ゼロを渡されて呼び出されたときブレークするようにできます:</p>

<!-- http://malisper.me/wp-content/uploads/2015/08/ezgif.com-optimize-4.gif -->


<p><img class="center" src="/images/2015-12-25/ezgif.com-optimize-4.gif" width="600"></p>

<p>式の中で関数に渡された引数を参照したいのでちょっとしたひねりが必要になっています。 他にも<strong>trace</strong> は <em>:break</em> の変種いくつかに対応しています。例えば <em>:break-after</em> はトレースされた関数が呼ばれる前ではなく呼ばれた後に式を評価するものです。 <em>:print</em> や <em>:print-after</em> は break に似ていますが、デバッガに入らず単に式の値をプリントします。<em>:print-after</em> を使って、例えば <strong>fib</strong> が実行から帰るたびに時刻(unix time)をプリントすることができます:</p>

<!-- http://malisper.me/wp-content/uploads/2015/08/ezgif.com-optimize-6.gif -->


<p><img class="center" src="/images/2015-12-25/ezgif.com-optimize-6.gif" width="600"></p>

<p><strong>trace</strong> の取れる引数の完全なリストを見たければ、 SBCL マニュアルの<a href="http://www.sbcl.org/1.0/manual/Function-Tracing.html">このページ</a>を見てみてください。</p>

<p>他にあまり知られていない機能は、相互参照(cross reference)コマンド群です。相互参照コマンドは、あるものが参照されているような場所をすべて見つけるコマンドです。これらのコマンドのキーバインディングはすべて C-c C-w で始まっています<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。私がもっともよく使う相互参照コマンドは &ldquo;slime-who-calls&rdquo; (C-c C-w C-c にバインドされています)で、これは関数が呼ばれている全ての場所を表示します。次の図は <strong>scan</strong> 関数が <a href="http://weitz.de/cl-ppcre/">cl-ppcre</a> というライブラリの中のどこで呼ばれているか見つけて、その中をスクロールしているところです<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>:</p>

<!-- http://malisper.me/wp-content/uploads/2015/08/ezgif.com-optimize-7.gif -->


<p><img class="center" src="/images/2015-12-25/ezgif.com-optimize-7.gif" width="600"></p>

<p>slime-who-calls は、関数がどのように使われることを想定しているか見るのに便利です。全ての用例を引っ張ってくることができるので、それを眺めるのです。slice-who-call にもいくらかの親戚がいます。 slime-who-macroexpands (C-c C-w RET) はマクロが使われている全ての場所を表示するもので、 slime-who-references (C-c C-w C-r) はそれの変数用バージョンです。</p>

<p>もうひとつ大事な機能として、デバッガの中にいるとき、あるスタックに対応する関数のソースコードを引っ張ってくるものがあります。それを使うひとつの方法は、ソースが見たいスタックにカーソルをもっていって &lsquo;v&rsquo; キーを押すことです。もしくは M-p ( Alt キーと &lsquo;p&rsquo; キーを同時に押す) と M-n を使ってスタックフレーム中を上下に動くという方法もあります。C-p C-n のかわりにこの2つのコマンドを使うと、 Slime は自動的に対応するソースコードを表示します。次の図は cl-ppcre に正しくない正規表現を渡して、エラーでデバッガに入り、スタックの中を M-n でたどっているところです:</p>

<!-- http://malisper.me/wp-content/uploads/2015/08/ezgif.com-optimize-9.gif -->


<p><img class="center" src="/images/2015-12-25/ezgif.com-optimize-9.gif" width="600"></p>

<p>そして IDE のコマンドで一番おなじみの機能、ソースへのジャンプです。最近私が話した人などは、IDE の機能は定義を簡単に探す機能しか使っていないと言っていました。Emacs で Slime を使うと、ほとんど何の定義でも &ldquo;M-.&rdquo; (Escキーの後にピリオドキー(訳注: あるいはAlt+ピリオドキー)) で飛ぶことができます。関数、変数、クラス、その他いろいろなもので動作します。総称関数 generic function の定義に飛ぼうとすると、それを実際に定義する全てのメソッド定義が表示されます。例えば <strong>create-matcher-aux</strong> (これは cl-ppcre ライブラリのほとんどの仕事を行っている関数です) の定義に飛ぼうとすると、図のようになります:</p>

<!-- http://malisper.me/wp-content/uploads/2015/08/ezgif.com-optimize-8.gif -->


<p><img class="center" src="/images/2015-12-25/ezgif.com-optimize-8.gif" width="600"></p>

<p>元の場所に戻るには &ldquo;M-,&rdquo; を使います。</p>

<p>そしてこれが、 Common Lisp のデバッグであなたが必要になるだろう知識のすべてです。</p>

<p>原文: <a href="http://malisper.me/2015/08/19/debugging-lisp-part-5-miscellaneous/">http://malisper.me/2015/08/19/debugging-lisp-part-5-miscellaneous/</a></p>

<!-- A keyword argument is an optional named argument. To use a keyword argument you pass in the the name of the argument, followed by the value. By using keyword arguments, a function can accept multiple optional arguments of which any subset can be used. -->




<!-- C-c is pressed because that is the binding Slime uses. C-w is pressed for “who”, which is binding for all of the cross referencing commands. -->




<!-- All of the places that use a macro whose expansion uses the function being cross referenced will also be pulled up. -->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>キーワード引数というのは名前がついたオプション引数です。キーワード引数を使うには、その名前と使いたい値を並べて関数に渡します。キーワード引数を使うと、関数は複数のオプション引数を持ったうえでその好きな一部分だけを受け取れるようになります。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>C-c は Slime 自体が使っているバインディングです。 C-w は &ldquo;who(誰が)&rdquo; の意味で、すべての相互参照コマンドがここに割り当てられています。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>マクロの使われている場所の中で、展開形の中でその関数が使われているような場所もすべて引っ張ってきます。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/25/debugging-lisp-part-4-restart/">Debugging Lisp Part 4: リスタート</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-25T02:07:20+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリーは、著者の許可をいただいて <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a> のCommon Lispのデバッグに関する連載を翻訳するものです。</p>

<hr />

<p>このエントリーは連載Debbugging Lispの第4回です。これまでに<a href="/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu">再コンパイル</a>、<a href="/blog/2015/12/22/debugging-lisp-part-2-insupekuto">インスペクト</a>、<a href="/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi/">クラスの再定義</a>について扱いました。</p>

<p>多くの言語において、エラーを扱う機能は2つに分かれています。いわゆる throw と catch です。 throw は何かが失敗したことを検知し、エラーを何らかの方法で通知します。このとき throw は発生した問題の情報を含んだ例外オブジェクトを作ります。一方 catch はこの例外オブジェクトを受け取って、エラーからの復帰を試みます。</p>

<p>throw / catch の問題は、 throw が catch への無条件の goto のように振る舞うことです。このため、 throw が呼ばれた状況について、例外オブジェクトに含められなかった情報の全ては失われてしまいます。これは catch する側のコードが、エラーからの復帰のためにエラー発生時のため欲しい情報があったとき問題になります。</p>

<p>たとえばあなたは、いくつかのファイルを取ってその中の数のリストをパースするようなライブラリを作っているとしましょう。その最初の関数 <strong>read-file</strong> は一つのファイルを読んで結果のリストを返します。2つ目の関数 <strong>read-files</strong> はファイルのリストを取って、各々のファイルの内容をさらにリストにして返します。以下はエラー処理を考えない場合のコードの例です:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun read-file (file)
</span><span class='line'>  (with-open-file (in file :direction :input)
</span><span class='line'>    (loop for line = (read-line in nil in)
</span><span class='line'>          until (eq in line)
</span><span class='line'>          collect (parse-integer line))))
</span><span class='line'> 
</span><span class='line'>(defun read-files (files)
</span><span class='line'>  (loop for file in files
</span><span class='line'>        collect (read-file file)))</span></code></pre></td></tr></table></div></figure>


<p>ライブラリをテストするために、あなたは手元にファイルを 2 つ持っています。1つ目の内容は 5, 10, 15, 20, 25 で、2つ目は 5, 10, 15, 20, a, 30, 40 です。ライブラリがエラーを正しく処理することを確かめるために、2つ目のファイルには &ldquo;a&rdquo; とだけ書かれた行を含めることにしたのです。現状では、 <strong>parse-integer</strong> がこの行でエラーを通知します。ライブラリのテストを簡単にするため、あなたは2つのファイルへのパスネームのリストを変数 <em>*files*</em> に保存しました。このライブラリをこの2つのファイルに対して走らせるとこうなります:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(read-files *files*)
</span><span class='line'> 
</span><span class='line'> =&gt; ERROR</span></code></pre></td></tr></table></div></figure>


<p>2つ目のファイルの &ldquo;a&rdquo; によってエラーが発生しました。あなたはライブラリの設計者として、このような状況で何が起こるべきか、決めなければいけません。使っている言語が catch / throw しか提供しない場合に取れる選択肢を見ていきましょう。</p>

<p>1つ目の選択肢は、単にエラーを起こした項目を無視することです。これを行うためには、Common Lisp での catch 機能にあたる <strong>handler-case</strong> を使うことができます:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun read-file (file)
</span><span class='line'>  (with-open-file (in file :direction :input)
</span><span class='line'>    (loop for line = (read-line in nil in)
</span><span class='line'>          until (eq in line)
</span><span class='line'>          when (handler-case (parse-integer line)
</span><span class='line'>                 ;; C is the name being used to
</span><span class='line'>                 ;; refer to the exception object.
</span><span class='line'>                 (error (c)
</span><span class='line'>                   (declare (ignore c))
</span><span class='line'>                   nil))
</span><span class='line'>          collect it)))
</span><span class='line'> 
</span><span class='line'>(read-files *files*)
</span><span class='line'> 
</span><span class='line'>=&gt; ((5 10 15 20 25) (5 10 15 20 30 40))</span></code></pre></td></tr></table></div></figure>


<p>もう一つの選択肢は、ライブラリのユーザーが設定出来るようなスペシャル変数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>を提供して、不正な値の代わりに用いられる値を設定出来るようにすることです:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defvar *malformed-value* nil)
</span><span class='line'> 
</span><span class='line'>(defun read-file (file)
</span><span class='line'>  (with-open-file (in file :direction :input)
</span><span class='line'>    (loop for line = (read-line in nil in)
</span><span class='line'>          until (eq in line)
</span><span class='line'>          when (handler-case (parse-integer line)
</span><span class='line'>                 (error (c)
</span><span class='line'>                   (declare (ignore c))
</span><span class='line'>                   *malformed-value*))
</span><span class='line'>          collect it)))
</span><span class='line'> 
</span><span class='line'>(let ((*malformed-value* :malformed))
</span><span class='line'>  (read-files *files*))
</span><span class='line'> 
</span><span class='line'>=&gt; ((5 10 15 20 25) (5 10 15 20 :MALFORMED 30 40))</span></code></pre></td></tr></table></div></figure>


<p>3つめの選択肢は、 <strong>read-files</strong> がエラーを catch して、不正な値の入ったファイル全体をスキップするようにすることです:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun read-files (files)
</span><span class='line'>  (loop for file in files
</span><span class='line'>        when (handler-case (read-file file)
</span><span class='line'>               (error (c)
</span><span class='line'>                 (declare (ignore c))
</span><span class='line'>                 nil))
</span><span class='line'>        collect it))
</span><span class='line'> 
</span><span class='line'>(read-files *files*)
</span><span class='line'> 
</span><span class='line'>=&gt; ((5 10 15 20 25))</span></code></pre></td></tr></table></div></figure>


<p>最後の選択肢は、ライブラリのユーザー自身に例外処理をまかせることです:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(handler-case (read-files *files*)
</span><span class='line'>  (error (c) (do-something)))</span></code></pre></td></tr></table></div></figure>


<p>ユーザーにとっては、最後の選択肢はいくらか有用です。エラーをどう処理するかの柔軟性があるからです。こうすることの問題は、上で述べたように、ユーザにとってはエラーから正しく復帰するようにすることが難しいことです。単にエラーが発生したファイル1つだけをスキップしたい場合、簡単な方法はありません。エラー処理のコードが走るのは関数 <strong>read-files</strong> を去ったあとだからです。これは残りの読むべきファイルなど、状態に関する全ての情報が catch の時には失われているということを意味します。</p>

<p>catch / throw についてのもう一つの問題は、上で上げた 4 つの選択肢のうち、あなたはたった 1 つしか選ぶことが出来ないということです。どの 1 つもほかの 4 つと競合してしまいます。これもやはり、 throw が goto のようにふるまうからです。一度どこへ飛ぶか決めたら、次にどうするかコントロールすることができません。エラーの処理をライブラリのユーザー自身にまかせることにしたなら、状態に関する情報が全て失われるために、ユーザーには簡単にエラーをうまく処理する方法がありません。</p>

<p>ここでリスタートが登場します。Common Lisp では、 catch は2つの異なる部分に分かれています: ハンドラー handler とリスタート restart です。ハンドラーはライブラリのユーザーが束縛し、例外が発生したときに何が起こるべきかを決めるためのものです。リスタートはエラーから復帰する選択肢を提供するため、ライブラリ側で定義します。
もしリスタートに対応した言語を使っていれば、先ほどの選択肢の最初の3つをリスタートとして実装することが出来ます。そしてユーザーがライブラリを使うときには、エラーの処理にそのうちどれを使いたいかを選ぶことが出来ます。以下が先ほどのライブラリを、先ほどの選択肢にそれぞれ対応する3つのリスタートが使えるよう再実装したものです:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun ask (string)
</span><span class='line'>  (princ string *query-io*)
</span><span class='line'>  (read *query-io*))
</span><span class='line'> 
</span><span class='line'>(defun read-file (file)
</span><span class='line'>  (with-open-file (in file :direction :input)
</span><span class='line'>    (loop for line = (read-line in nil in)
</span><span class='line'>          until (eq in line)
</span><span class='line'>          when (restart-case (parse-integer line)
</span><span class='line'>                 (use-value (value)
</span><span class='line'>                   :report "Use a new value."
</span><span class='line'>                   :interactive (lambda ()
</span><span class='line'>                                  (list (ask "Value: ")))
</span><span class='line'>                   value)
</span><span class='line'>                 (skip-entry ()
</span><span class='line'>                   :report "Skip the entry."
</span><span class='line'>                   nil))
</span><span class='line'>          collect it)))
</span><span class='line'> 
</span><span class='line'>(defun read-files (files)
</span><span class='line'>  (loop for file in files
</span><span class='line'>        when (restart-case (read-file file)
</span><span class='line'>               (skip-file ()
</span><span class='line'>                 :report "Skip the entire file."
</span><span class='line'>                 nil))
</span><span class='line'>        collect it))
</span><span class='line'> 
</span><span class='line'>;;; The three functions below are predefined
</span><span class='line'>;;; handlers for the most common ways the user
</span><span class='line'>;;; will interact with the restarts.
</span><span class='line'>(defun skip-entry (c)
</span><span class='line'>  (declare (ignore c))
</span><span class='line'>  (invoke-restart 'skip-entry))
</span><span class='line'> 
</span><span class='line'>(defun skip-file  (c)
</span><span class='line'>  (declare (ignore c))
</span><span class='line'>  (invoke-restart 'skip-file))
</span><span class='line'> 
</span><span class='line'>(defun use-value-handler (value)
</span><span class='line'>  (lambda (c)
</span><span class='line'>    (declare (ignore c))
</span><span class='line'>    (invoke-restart 'use-value value)))</span></code></pre></td></tr></table></div></figure>


<p>リスタートはマクロ <strong>restart-case</strong> で定義され、関数 <strong>invoke-restart</strong> によって呼び出されます。いくらか簡略化して言うと、リスタートを呼び出すとのは、エラーが通知されたところからリスタートの本体(body)にジャンプするのと実際上同じことです。これは、リスタートが確立された時点でスタックに保存されていた全ての状態が、リスタートが呼び出された時点でまだ使えるということを意味します。これにより、ライブラリのユーザーに、エラー発生時にどうするかについてずっと粒度の細かいコントロールを与えることができます。</p>

<p>エラー時に何が起こるべきかユーザーが決めるには、マクロ <strong>handler-bind</strong> を使うだけです。 <strong>handler-bind</strong> はエラーの種類と、その種類のエラーが通知されたときに呼び出すべきハンドラー(これは関数のはずです)を引数に取ります。ハンドラーはそのとき <strong>invoke-restart</strong> を呼ぶことで、ライブラリが持っているリスタートのうち一つを呼び出します。上のライブラリのコードには、リスタートひとつにつきひとつのハンドラー関数が用意してありますが、これはこれらが最もよくある種類のハンドラーだからです。以下はそれぞれのハンドラーが先ほどの2つのファイルに対して使われたときの例です:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(handler-bind ((error #'skip-entry))
</span><span class='line'>  (read-files files*))
</span><span class='line'> 
</span><span class='line'>=&gt; ((5 10 15 20 25) (5 10 15 20 30 40))
</span><span class='line'> 
</span><span class='line'>(handler-bind ((error #'skip-file))
</span><span class='line'>  (read-files files*))
</span><span class='line'> 
</span><span class='line'>=&gt; ((5 10 15 20 25))
</span><span class='line'> 
</span><span class='line'>(handler-bind ((error (use-value-handler 0)))
</span><span class='line'>  (read-files files*))
</span><span class='line'> 
</span><span class='line'>=&gt; ((5 10 15 20 25) (5 10 15 20 0 30 40))</span></code></pre></td></tr></table></div></figure>


<p>リスタートが本当にクールなのは、ユーザーがハンドラーを設定していなかったときの振る舞いです。この場合ユーザーはSlimeデバッガに入ることになります。可能なリスタートのリストが提示されて、まるで最初からエラーがハンドリングされていたかのようにエラーを処理することができます！以下はユーザーがエラーをハンドルせず、そして実行中に (デバッガから) skip-entry リスタートを選んだ時の様子です:</p>

<!-- http://malisper.me/wp-content/uploads/2015/08/ezgif.com-optimize-3.gif -->


<p><img class="center" src="/images/2015-12-25/ezgif.com-optimize-3.gif" width="600"></p>

<p>さらにクールなこととして、この"対話的リスタート"はブレークポイントを実装するのに使えます！第1回で書いたように、 Common Lisp はブレークポイントをエディタの機能としてではなく関数 &ldquo;<strong>break</strong>&rdquo; として提供しています。例えば次のような実装ができるでしょう:</p>

<pre><code>(defun break (&amp;optional (format-control "Break")
              &amp;rest format-arguments)
   (with-simple-restart (continue "Return from BREAK.")
     (let ((*debugger-hook* nil))
       (invoke-debugger
         (make-condition 'simple-condition
           :format-control   format-control
           :format-arguments format-arguments))))
   nil)
</code></pre>

<p>このコードは &ldquo;continue&rdquo; というリスタートを用意してからエラーを通知することで動作します。つまり、<strong>break</strong>が呼ばれた直後、実行を続行するという選択肢つきのデバッガに入るわけです。この動作はブレークポイントそのものです。</p>

<p>リスタートは Common Lisp のデバッギングにおける素晴らしい機能のひとつです。エラーが発生したとき、よりよい制御を可能にしてくれます。しかも、自分でそれをハンドルしなかったときには対話的にリスタートを選んでコードの実行を続けられるのです。</p>

<p>原文: <a href="http://malisper.me/2015/08/05/debugging-lisp-part-4-restarts/">http://malisper.me/2015/08/05/debugging-lisp-part-4-restarts/</a></p>

<!-- A dynamic variable is basically a global variable that can be shadowed. When a dynamic variable is shadowed, any reference to it refers to the new binding. Once execution leaves the form that shadowed the dynamic variable, the dynamic variable reverts back to its previous binding. -->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>ダイナミック変数とは、要するにシャドウ(shadow、覆い隠す)可能なグローバル変数です。ダイナミック変数がシャドウされると、変数に対するすべての参照は新しい値を指すようになります。変数をシャドウしたフォームから抜けた時点で、ダイナミック変数は以前の値に戻ります。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi/">Debugging Lisp Part 3: クラスの再定義</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-22T00:35:33+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:35 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリーは、著者の許可をいただいて <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a> のCommon Lispのデバッグに関する連載を翻訳するものです。</p>

<hr />

<p>このエントリーは連載 Debbugging Lisp の第3回です。第1回は<a href="/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu">こちら</a>、第2回は<a href="/blog/2015/12/22/debugging-lisp-part-2-insupekuto">こちら</a>。</p>

<p>Common Lisp Object System (CLOS) は非常に強力です。多重継承、多重ディスパッチ、メソッドの振る舞いを拡張するさまざまな異なるやり方を提供します。その内部では、ほとんどの実装は Metaobject Protocol(MOP) を使っています。これは CLOS 自身を使って CLOS を定義するものです。 MOP では、クラスはいくつかのインスタンス変数を持ったオブジェクトとして実装されます。そのインスタンス変数としては、クラス名、スーパークラス、またそのクラスの持つインスタンス変数のリストなどがあります。前回のエントリーの point クラスを見てみましょう:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defclass point ()
</span><span class='line'>  ((x :accessor point-x :initarg :x :initform 0)
</span><span class='line'>   (y :accessor point-y :initarg :y :initform 0)))</span></code></pre></td></tr></table></div></figure>


<p>そして Slime インスペクタを使って point クラスオブジェクトを見てみましょう。クラスオブジェクトは関数 <strong>find-class</strong> で見つけることができます:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize1.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-optimize1.gif" width="600"></p>

<p>MOP の利点は、 CLOS の振る舞いを微調整したいときには普通のオブジェクト指向プログラミングによって行えるということです。優れた例として、任意の述語(predecated)を CLOS のディスパッチに使えるようにする<a href="https://common-lisp.net/project/closer/filtered.html">filterd-functions</a>ライブラリがあります。MOPについてはもういいでしょう<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。このエントリーでは CLOS の小さな一部分である、 <strong>update-instance-for-redefined-class</strong> についてお話しします。</p>

<p><strong>update-instance-for-redefined-class</strong> は、クラスが(実行時に)再定義される度に呼ばれるメソッドです。これをオーバーライドすることでクラス再定義の際の振る舞いをカスタマイズすることが出来ます。
たとえば何かのシミュレーション中で、先ほどのpointクラスを複素数を表すのに使っていたとしましょう。シミュレーションの一部として、pointオブジェクトを変数 <em>*location*</em> に保存しています。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-1.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-optimize-1.gif" width="600"></p>

<p>シミュレーションをプロファイリングしてみると、ボトルネックの一つが複素数同士のかけ算であることに気付きました。複素数のかけ算は極座標表示での方がずっと効率的ですから、あなたは point クラスの実装を直交座標から極座標に変えることにしました。これを(実行中に)行うためには、次のコードを走らせるだけです:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmethod update-instance-for-redefined-class :before
</span><span class='line'>     ((pos point) added deleted plist &key)
</span><span class='line'>  (let ((x (getf plist 'x))
</span><span class='line'>        (y (getf plist 'y)))
</span><span class='line'>    (setf (point-rho pos) (sqrt (+ (* x x) (* y y)))
</span><span class='line'>          (point-theta pos) (atan y x))))
</span><span class='line'> 
</span><span class='line'>(defclass point ()
</span><span class='line'>  ((rho :initform 0 :accessor point-rho)
</span><span class='line'>   (theta :initform 0 :accessor point-theta)))
</span><span class='line'> 
</span><span class='line'>(defmethod point-x ((pos point))
</span><span class='line'>  (with-slots (rho theta) pos (* rho (cos theta))))
</span><span class='line'> 
</span><span class='line'>(defmethod point-y ((pos point))
</span><span class='line'>  (with-slots (rho theta) pos (* rho (sin theta))))</span></code></pre></td></tr></table></div></figure>


<p>これは要するに、 <strong>update-instance-for-redefined-class</strong> を拡張して、極座標実装での値 <em>rho</em> と <em>theta</em> を直交座標実装の値から計算するものです。 <strong>update-instance-for-redefined-class</strong> を拡張した後、このコードはクラスを再定義して、その時存在する全てのインスタンスを新しいクラスのインスタンスに変換します<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。
そして最後に、二つのメソッド <strong>point-x</strong> と <strong>point-y</strong> を定義し、 point クラスの元のインターフェースを保ちます<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。コードを走らせてから <em>*location*</em> の中身をインスペクトすると、次のようなものが見えるはずです:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-21.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-optimize-21.gif" width="600"></p>

<p><em>*location*</em> は依然として同一のオブジェクトを指しているものの、今やそれは極座標実装になっています！ 正しく変換されたことを確かめるため、あなたはこのオブジェクトを与えて <strong>point-x</strong> 関数を呼び出し、 x 座標が同じままかどうか確かめることにしました:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop1.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-crop1.gif" width="600"></p>

<p>驚くべきことに、クラスの実装を完全に置き換えたにもかかわらず、全てのコードは動作し続けます。もしあなたが24時間365日動き続けていなければならないサービス内でクラスの実装を変更したくて、しかもそれがたまたま Common Lisp で書かれていたなら、 <strong>update-instance</strong> を使うことを思い出してください。</p>

<p>原文: <a href="http://malisper.me/2015/07/22/debugging-lisp-part-3-redefining-classes/">http://malisper.me/2015/07/22/debugging-lisp-part-3-redefining-classes/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>MOPについてもっと学びたい方は、"The Art of the Metaobject Protocol"を手に取ってみてください。オブジェクト指向プログラミングを作った人であるアラン・ケイは、1997年のOOPSLAでの講演でこの本を「この10年で最も良い本」だと言いました。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>実際には、どの時点でupdate-instance-for-redefined-classが呼ばれるかは仕様では策定されていません。 保証されているのは、最初にインスタンス変数がアクセスされるまでに呼ばれるということだけです。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>本当にインターフェースを保存するためには initialize-instance などいくつか他の関数も定義し直す必要はあります。<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/22/debugging-lisp-part-2-insupekuto/">Debugging Lisp Part 2: インスペクト</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-22T00:17:50+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:17 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリーは、著者の許可をいただいて <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a> のCommon Lispのデバッグに関する連載を翻訳するものです。</p>

<hr />

<p>このエントリーは連載 Debugging Lispの第2回です。第1回は<a href="/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu">こちら</a>。</p>

<p>このエントリーではCommon Lispのもう一つのデバッグツール、Slimeのインスペクタについて議論します。
Slimeインスペクタは、オブジェクトをreplから直接操作することを可能にします。
色々なことができ、例えばオブジェクトをクリックして内容をみることもできますし、オブジェクトをコピーアンドペーストして後の関数呼び出しで使うこともできます<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。
次のようなpointクラスがあるとしましょう:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defclass point ()
</span><span class='line'>  ((x :accessor point-x :initarg :x :initform 0)
</span><span class='line'>   (y :accessor point-y :initarg :y :initform 0)))</span></code></pre></td></tr></table></div></figure>


<p>このクラスのインスタンスを作るには次のようにします:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(make-instance 'point :x 10 :y 20)</span></code></pre></td></tr></table></div></figure>


<p>返されたオブジェクトを右クリックして"inspect"オプションを選ぶか、emacsのショートカット"C-v C-v TAB"を使うことでオブジェクトの中をのぞくことができます:</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-5.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-optimize-5.gif" width="600"></p>

<p>全てのインスタンス変数の現在の値が表示されます。表示するだけでなく、変数の値を変更することも出来ます。これらがデバッガ内から、実行時に使えることが強力なのだということに注意してください。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-7.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-optimize-7.gif" width="600"></p>

<p>実際にオブジェクトの値が変更されたことを確認するには、このオブジェクトをコピーアンドペーストし、 <strong>point-x</strong> 関数に与えて呼び出すことができます。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-5.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-crop-5.gif" width="600"></p>

<p>インスペクタに関してもう一つとてもクールなのは、Slimeのトレースダイアログです。トレースダイアログは普通のトレースに似ていますが、トレースされている関数が渡されたり返すオブジェクトがインスペクトできるようになっています。例えば、あなたが次のような末尾再帰最適化された関数 <strong>sum</strong> を書いているとしましょう。これはリストの中の全ての数を足し合わせます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun sum (xs &optional (acc 0))
</span><span class='line'>  (if (null xs)
</span><span class='line'>      acc
</span><span class='line'>      (sum (cdr xs) (+ (car xs) acc))))
</span><span class='line'> 
</span><span class='line'>(sum '(1 2 3))
</span><span class='line'>=&gt; 6</span></code></pre></td></tr></table></div></figure>


<p>関数 <strong>sum</strong> をトレースするかどうかは、ショートカット &ldquo;C-c M-t&rdquo; の後、関数の名前 &ldquo;<strong>sum</strong>&rdquo; を打つことで切り替えることができます。関数をトレースした後、"C-c T"でインタラクティブなトレースダイアログのバッファに入れます。"G"を押すことで情報を更新して一番最後のトレースを得ることができます。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-4.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-crop-4.gif" width="600"></p>

<p>このトレースは普通のトレースと大体同じ見た目をしていますが、よい機能があります。上で述べたように、関数の全ての引数と返り値をインスペクトすることができるのです。見やすいようにトレースの枝の表示/非表示を切り替えることも出来ます。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-8.gif -->


<p><img class="center" src="/images/2015-12-22/ezgif.com-optimize-8.gif" width="600"></p>

<p>Slimeのトレースダイアログは、コードが多数のオブジェクトをやりとりしていて、自分がその中身について確信が持てないときに非常に有用です。これを使うだけであなたに必要な情報の全てを追ってくれるのです。</p>

<p>SlimeのインスペクタはCommon Lispのデバッグツール群のもう一つの素晴らしい機能です。プログラムがクラッシュし、原因が分からないときに重宝します。他のデバッグツール群と組み合わされば最高です。</p>

<p>原文: <a href="http://malisper.me/2015/07/14/debugging-lisp-part-2-inspecting/">http://malisper.me/2015/07/14/debugging-lisp-part-2-inspecting/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>技術的にはこれはインスペクタの機能ではなく"Presentation"の機能です。インスペクタはオブジェクトの中を見る機能にあたります。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/19/debugging-lisp-part-1-zai-konpairu/">Debugging Lisp Part 1: 再コンパイル</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-19T01:52:44+01:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>このエントリーは、著者 Michael Malis 氏の許可をいただき、Common Lispのデバッグに関する連載 <a href="http://malisper.me/category/debugging-common-lisp/">http://malisper.me/category/debugging-common-lisp/</a>  を翻訳するものです。</p>

<!-- もともとは[Lisp Advent Calendar 2015](http://qiita.com/advent-calendar/2015/lisp)の第18日目とし、全部翻訳して載せようかと思っていたのですが、間に合わなかったため第1回をまず掲載します。クリスマスまでに残りを掲載する予定です。サイトを作りたてでコメント欄は後で設置するつもりですが、その前に何かありましたらredditのコメント欄などは多分見てますので遠慮なくお寄せください。 -->


<hr />

<p>このエントリーはCommon Lispのデバッギング、特にEmacs、Slime、SBCLを用いた場合に関する連載の第1回です。Common Lispを知らない人でも少なくとも追うことはでき、Common Lispのデバッガが提供するものがいかにパワフルかわかるはずです。このエントリー群はNathan Marzに書くよう頼まれたものです。彼はCommon Lispをデバッグする多くのツール群がクールだと考えたのです。</p>

<p>Common Lispのデバッグを始めるに当たって最初に、あなたのLispで最適化の指定をする必要があります。Common Lispでは、コードのコンパイルにあたって何の項目を重要視すべきかを設定することができます。項目としてはたとえば実行速度、メモリ量、コンパイル速度、そしてデバッグがあります。以下のコードを走らせなければ、このエントリーで以下示すコードのほとんどは動作しません。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CL-USER&gt; (declaim (optimize (debug 3)))
</span><span class='line'>NIL
</span><span class='line'>
</span><span class='line'>CL-USER&gt; (your-program)
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>デバッグを優先してコンパイルすることにしたので、実行時に色々なことができるようになりました。
以下ではベテランのCommon Lisp開発者(トムとしましょう)に登場してもらい、彼がどのようにデバッグを行い、バグを含んだ関数を修正するかを示して行きます。トムの手元に、フィボナッチ関数を計算する次のようなコードがあるとします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun fib (n)
</span><span class='line'>  (if (&lt;= 0 n 1)
</span><span class='line'>      (/ 1 0)
</span><span class='line'>      (+ (fib (- n 1))
</span><span class='line'>         (fib (- n 2)))))</span></code></pre></td></tr></table></div></figure>


<p>このコードには問題が一つあります。正しくないということです！base caseでnを返すはずが、ゼロ除算を行ってしまいます。トムが10番目のフィボナッチ数を計算しようとするとデバッガウィンドウが現れます。エラーが通知されたからです。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop.gif -->


<p><img class="center" src="/images/2015-12-19/ezgif.com-crop.gif" width="600"></p>

<p>トムはデバッガに入ったことに気付いて、何がまずかったのか考えます。バグを見つけるため、トムは関数にブレークポイントを挿入することにしました<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。Common Lispでは、ブレークポイントは関数として実装されており、"break"という名前です<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。ブレークポイントを挿入するため、トムは <strong>fib</strong> の最初に <strong>break</strong> の呼び出しを追加しました(訳注: 関数定義のコードにカーソルを置いてC-c C-cを押すことでその関数を再コンパイルします)。ブレークポイントを追加したトムは、次に一つのフレームのところにカーソルを持って行ったのち、'r'キーを押しました。これでそのフレームから実行を再開(リスタート)できます。トムは <em>n</em> が 3 だったフレームをリスタートすることにしました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize.gif -->


<p><img class="center" src="/images/2015-12-19/ezgif.com-optimize.gif" width="600"></p>

<p>フレームをリスタートすることで、トムは要するにそのフレームまで時間を巻き戻すことができます。リスタートをすると、デバッガはトムが挿入したブレークポイントにただちにぶつかります。トムはそこから&rsquo;s'キーを押してプログラムを1ステップずつ実行します。最終的に彼は base case の実装が正しくないためにエラーが出ていることに気付きました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-2.gif -->


<p><img class="center" src="/images/2015-12-19/ezgif.com-optimize-2.gif" width="600"></p>

<p>さて、エラーの原因がわかりました。ブレークポイントを挿入したときと同じようにして、トムがコードを修正します。base caseを <em>n</em> で置き換えて、先ほど挿入したブレークポイントを取り除きました。</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-optimize-3.gif -->


<p><img class="center" src="/images/2015-12-19/ezgif.com-optimize-3.gif" width="600"></p>

<p>再コンパイルすると、トムはまたあるフレームからリスタートしました。先ほどコードをステップ実行していたところだったので、デバッガはフレームの中をステップ実行し始めました。トムが"0"(ゼロ)キーを押して step-continue という名のリスタートを呼ぶと、デバッガは通常実行に戻りました。このときトムはまだバグに遭遇する前のフレームからリスタートしたので、コードはあたかも最初からバグがなかったかのように走ります！</p>

<!-- http://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop-3.gif -->


<p><img class="center" src="/images/2015-12-19/ezgif.com-crop-3.gif" width="600"></p>

<p>まとめましょう。コードがエラーを通知すると、トムはデバッガに入っていることに気付きます。トムはコードにブレークポイントを挿入し、バグをつきとめるまでコードの振る舞いを追うことができます。トムがコードを修正したため、彼がフレームをリスタートするとコードは初めからバグがなかったかのように振る舞いました！</p>

<p>実行時にコードを再コンパイルできるのは、Common Lispが備えるたくさんの驚くべき特徴のうちたったひとつにすぎません。次回は、デバッガ内からオブジェクトを調べたり変更するための、Slimeのインスペクタについてお話しします。</p>

<p>原文: <a href="http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/">http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>彼はすばらしいプログラマーかもしれませんが、エラーメッセージを読まないのです。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>breakはそれ自体がCommon Lispのリスタート(restart)という仕組みで実装されています。リスタートについては第4回で扱います。<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>About</h1>
  <p>Python とか Common Lisp とかが好きな物理実験系の大学院生。あとライフゲームとか。</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/25/roswell-lesser-less/">Roswellでlessもどきを作ってみる</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/25/debugging-lisp-translation/">Debugging Lisp を翻訳しました</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/25/debugging-lisp-part-5-miscellaneous/">Debugging Lisp Part 5: その他こまごま</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/25/debugging-lisp-part-4-restart/">Debugging Lisp Part 4: リスタート</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/22/debugging-lisp-part-3-kurasufalsezai-ding-yi/">Debugging Lisp Part 3: クラスの再定義</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/glider-gun">@glider-gun</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'glider-gun',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - glider-gun -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'glider-gun';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
